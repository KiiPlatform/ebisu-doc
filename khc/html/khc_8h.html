<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>khc: include/khc.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">khc
   </div>
   <div id="projectbrief">khc is light-weight HTTP client written in C.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">khc.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br />
<code>#include &quot;<a class="el" href="khc__socket__callback_8h_source.html">khc_socket_callback.h</a>&quot;</code><br />
</div>
<p><a href="khc_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkhc__slist.html">khc_slist</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linked list.  <a href="structkhc__slist.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkhc.html">khc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">khc object.  <a href="structkhc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a57e8d1b5da9a4222190c74f8fb87a304"><td class="memItemLeft" align="right" valign="top">typedef size_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="khc_8h.html#a57e8d1b5da9a4222190c74f8fb87a304">KHC_CB_WRITE</a>) (char *buffer, size_t size, void *userdata)</td></tr>
<tr class="memdesc:a57e8d1b5da9a4222190c74f8fb87a304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback writes data.  <a href="#a57e8d1b5da9a4222190c74f8fb87a304">More...</a><br /></td></tr>
<tr class="separator:a57e8d1b5da9a4222190c74f8fb87a304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b82452e6a8981c670e9eef8450a7ce4"><td class="memItemLeft" align="right" valign="top">typedef size_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="khc_8h.html#a3b82452e6a8981c670e9eef8450a7ce4">KHC_CB_READ</a>) (char *buffer, size_t size, void *userdata)</td></tr>
<tr class="memdesc:a3b82452e6a8981c670e9eef8450a7ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback reads data.  <a href="#a3b82452e6a8981c670e9eef8450a7ce4">More...</a><br /></td></tr>
<tr class="separator:a3b82452e6a8981c670e9eef8450a7ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28da65fe4a96bed6b6ac8150b9481a20"><td class="memItemLeft" align="right" valign="top">typedef size_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="khc_8h.html#a28da65fe4a96bed6b6ac8150b9481a20">KHC_CB_HEADER</a>) (char *buffer, size_t size, void *userdata)</td></tr>
<tr class="memdesc:a28da65fe4a96bed6b6ac8150b9481a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback used to propagate response headers.  <a href="#a28da65fe4a96bed6b6ac8150b9481a20">More...</a><br /></td></tr>
<tr class="separator:a28da65fe4a96bed6b6ac8150b9481a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405624d71b2722c439683872c851fc8b"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structkhc__slist.html">khc_slist</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="khc_8h.html#a405624d71b2722c439683872c851fc8b">khc_slist</a></td></tr>
<tr class="memdesc:a405624d71b2722c439683872c851fc8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linked list.  <a href="#a405624d71b2722c439683872c851fc8b">More...</a><br /></td></tr>
<tr class="separator:a405624d71b2722c439683872c851fc8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d588005d08dee796a1c9c830dc4590"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structkhc__slist.html">khc_slist</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="khc_8h.html#ab4d588005d08dee796a1c9c830dc4590">KHC_CB_SLIST_ALLOC</a>) (const char *str, size_t str_length, void *data)</td></tr>
<tr class="memdesc:ab4d588005d08dee796a1c9c830dc4590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom <a class="el" href="structkhc__slist.html" title="Linked list. ">khc_slist</a> node allocator.  <a href="#ab4d588005d08dee796a1c9c830dc4590">More...</a><br /></td></tr>
<tr class="separator:ab4d588005d08dee796a1c9c830dc4590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bafb6cf1da963a57d8a167efe9f833"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="khc_8h.html#a32bafb6cf1da963a57d8a167efe9f833">KHC_CB_SLIST_FREE</a>) (<a class="el" href="structkhc__slist.html">khc_slist</a> *node, void *data)</td></tr>
<tr class="separator:a32bafb6cf1da963a57d8a167efe9f833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53a38ebe7cf84dfb5f5892785c74b8f"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="khc_8h.html#a857caeeab83df303d0fe3a7d97601d0f">khc_state</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="khc_8h.html#ae53a38ebe7cf84dfb5f5892785c74b8f">khc_state</a></td></tr>
<tr class="memdesc:ae53a38ebe7cf84dfb5f5892785c74b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate state of khc.  <a href="#ae53a38ebe7cf84dfb5f5892785c74b8f">More...</a><br /></td></tr>
<tr class="separator:ae53a38ebe7cf84dfb5f5892785c74b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d0cf229865208373ee2c8d2c24cbcc"><td class="memItemLeft" align="right" valign="top"><a id="a65d0cf229865208373ee2c8d2c24cbcc"></a>
typedef enum <a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789">khc_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="khc_8h.html#a65d0cf229865208373ee2c8d2c24cbcc">khc_code</a></td></tr>
<tr class="memdesc:a65d0cf229865208373ee2c8d2c24cbcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error codes. <br /></td></tr>
<tr class="separator:a65d0cf229865208373ee2c8d2c24cbcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962c972213b49a6581a83f890fe22a0b"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structkhc.html">khc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="khc_8h.html#a962c972213b49a6581a83f890fe22a0b">khc</a></td></tr>
<tr class="memdesc:a962c972213b49a6581a83f890fe22a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">khc object.  <a href="#a962c972213b49a6581a83f890fe22a0b">More...</a><br /></td></tr>
<tr class="separator:a962c972213b49a6581a83f890fe22a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a857caeeab83df303d0fe3a7d97601d0f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="khc_8h.html#a857caeeab83df303d0fe3a7d97601d0f">khc_state</a> { <br />
&#160;&#160;<b>KHC_STATE_IDLE</b>, 
<b>KHC_STATE_CONNECT</b>, 
<b>KHC_STATE_REQ_LINE</b>, 
<b>KHC_STATE_REQ_HOST_HEADER</b>, 
<br />
&#160;&#160;<b>KHC_STATE_REQ_HEADER</b>, 
<b>KHC_STATE_REQ_HEADER_SEND</b>, 
<b>KHC_STATE_REQ_HEADER_SEND_CRLF</b>, 
<b>KHC_STATE_REQ_HEADER_END</b>, 
<br />
&#160;&#160;<b>KHC_STATE_REQ_BODY_READ</b>, 
<b>KHC_STATE_REQ_BODY_SEND_SIZE</b>, 
<b>KHC_STATE_REQ_BODY_SEND</b>, 
<b>KHC_STATE_REQ_BODY_SEND_CRLF</b>, 
<br />
&#160;&#160;<b>KHC_STATE_RESP_STATUS_READ</b>, 
<b>KHC_STATE_RESP_STATUS_PARSE</b>, 
<b>KHC_STATE_RESP_HEADER_CALLBACK</b>, 
<b>KHC_STATE_RESP_HEADER_READ</b>, 
<br />
&#160;&#160;<b>KHC_STATE_RESP_HEADER_SKIP</b>, 
<b>KHC_STATE_RESP_BODY_FRAGMENT</b>, 
<b>KHC_STATE_READ_CHUNK_SIZE_FROM_HEADER_BUFF</b>, 
<b>KHC_STATE_READ_CHUNK_BODY_FROM_HEADER_BUFF</b>, 
<br />
&#160;&#160;<b>KHC_STATE_RESP_BODY_READ</b>, 
<b>KHC_STATE_RESP_BODY_CALLBACK</b>, 
<b>KHC_STATE_RESP_BODY_PARSE_CHUNK_SIZE</b>, 
<b>KHC_STATE_RESP_BODY_READ_CHUNK_SIZE</b>, 
<br />
&#160;&#160;<b>KHC_STATE_RESP_BODY_PARSE_CHUNK_BODY</b>, 
<b>KHC_STATE_RESP_BODY_READ_CHUNK_BODY</b>, 
<b>KHC_STATE_RESP_BODY_SKIP_CHUNK_BODY_CRLF</b>, 
<b>KHC_STATE_RESP_BODY_SKIP_TRAILERS</b>, 
<br />
&#160;&#160;<b>KHC_STATE_CLOSE</b>, 
<b>KHC_STATE_FINISHED</b>
<br />
 }<tr class="memdesc:a857caeeab83df303d0fe3a7d97601d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate state of khc.  <a href="khc_8h.html#a857caeeab83df303d0fe3a7d97601d0f">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a857caeeab83df303d0fe3a7d97601d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90be23875108e9a39942c3af90a6d789"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789">khc_code</a> { <br />
&#160;&#160;<a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789ad362084b96bd996b692883323f38a71d">KHC_ERR_OK</a>, 
<a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789a63860890be328ec70b59ee94e6b3fa79">KHC_ERR_SOCK_CONNECT</a>, 
<a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789a8371726af4f71dd9286834d572befa8a">KHC_ERR_SOCK_CLOSE</a>, 
<a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789a23f70a0ca5536d5538cd259c0988a5d1">KHC_ERR_SOCK_SEND</a>, 
<br />
&#160;&#160;<a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789aa19da1c09bffcd5bf90a4a52295e8054">KHC_ERR_SOCK_RECV</a>, 
<a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789a87e69245b830da2d3cfee093ee5db0ee">KHC_ERR_HEADER_CALLBACK</a>, 
<a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789af5c7c4c210efc30b9d3cf642a0342f52">KHC_ERR_WRITE_CALLBACK</a>, 
<a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789a312c4dc6d68bf167f83aedc8def54cb1">KHC_ERR_ALLOCATION</a>, 
<br />
&#160;&#160;<a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789abdc61249fe00e89ee9f2d00f11561e13">KHC_ERR_TOO_LARGE_DATA</a>, 
<b>KHC_ERR_FAIL</b>
<br />
 }<tr class="memdesc:a90be23875108e9a39942c3af90a6d789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error codes.  <a href="khc_8h.html#a90be23875108e9a39942c3af90a6d789">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a90be23875108e9a39942c3af90a6d789"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4fd09852c48bd9160a7449acac61210a"><td class="memItemLeft" align="right" valign="top"><a id="a4fd09852c48bd9160a7449acac61210a"></a>
<a class="el" href="structkhc__slist.html">khc_slist</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="khc_8h.html#a4fd09852c48bd9160a7449acac61210a">khc_cb_slist_alloc</a> (const char *str, size_t str_len, void *data)</td></tr>
<tr class="memdesc:a4fd09852c48bd9160a7449acac61210a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of KHC_CB_SLIST_ALLOC. <br /></td></tr>
<tr class="separator:a4fd09852c48bd9160a7449acac61210a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ee1aa7bad924b214164a031a63bcf8"><td class="memItemLeft" align="right" valign="top"><a id="af8ee1aa7bad924b214164a031a63bcf8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="khc_8h.html#af8ee1aa7bad924b214164a031a63bcf8">khc_cb_slist_free</a> (<a class="el" href="structkhc__slist.html">khc_slist</a> *slist, void *data)</td></tr>
<tr class="memdesc:af8ee1aa7bad924b214164a031a63bcf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of KHC_CB_SLIST_FREE. <br /></td></tr>
<tr class="separator:af8ee1aa7bad924b214164a031a63bcf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a21016c7cd604d2476b97a8f6521106"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structkhc__slist.html">khc_slist</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="khc_8h.html#a8a21016c7cd604d2476b97a8f6521106">khc_slist_append</a> (<a class="el" href="structkhc__slist.html">khc_slist</a> *slist, const char *string, size_t length)</td></tr>
<tr class="memdesc:a8a21016c7cd604d2476b97a8f6521106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add node to the linked list.  <a href="#a8a21016c7cd604d2476b97a8f6521106">More...</a><br /></td></tr>
<tr class="separator:a8a21016c7cd604d2476b97a8f6521106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda920e221cf9a457dd9e3f82197d2d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structkhc__slist.html">khc_slist</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="khc_8h.html#acda920e221cf9a457dd9e3f82197d2d7">khc_slist_append_using_cb_alloc</a> (<a class="el" href="structkhc__slist.html">khc_slist</a> *slist, const char *string, size_t length, <a class="el" href="khc_8h.html#ab4d588005d08dee796a1c9c830dc4590">KHC_CB_SLIST_ALLOC</a> cb_alloc, void *cb_alloc_data)</td></tr>
<tr class="memdesc:acda920e221cf9a457dd9e3f82197d2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add node to the linked list. Node is allocated by specified allocator.  <a href="#acda920e221cf9a457dd9e3f82197d2d7">More...</a><br /></td></tr>
<tr class="separator:acda920e221cf9a457dd9e3f82197d2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0697b94cf117f1e6475d4b6a281fdab6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="khc_8h.html#a0697b94cf117f1e6475d4b6a281fdab6">khc_slist_free_all</a> (<a class="el" href="structkhc__slist.html">khc_slist</a> *slist)</td></tr>
<tr class="memdesc:a0697b94cf117f1e6475d4b6a281fdab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory used for the entire linked list.  <a href="#a0697b94cf117f1e6475d4b6a281fdab6">More...</a><br /></td></tr>
<tr class="separator:a0697b94cf117f1e6475d4b6a281fdab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601f7b3c5298824462683436df2807fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="khc_8h.html#a601f7b3c5298824462683436df2807fa">khc_slist_free_all_using_cb_free</a> (<a class="el" href="structkhc__slist.html">khc_slist</a> *slist, <a class="el" href="khc_8h.html#a32bafb6cf1da963a57d8a167efe9f833">KHC_CB_SLIST_FREE</a> cb_free, void *cb_free_data)</td></tr>
<tr class="memdesc:a601f7b3c5298824462683436df2807fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory used for the entire linked list constructed by custom allocator.  <a href="#a601f7b3c5298824462683436df2807fa">More...</a><br /></td></tr>
<tr class="separator:a601f7b3c5298824462683436df2807fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb75ed1f039e02286cacb8d097f233e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="khc_8h.html#a5cb75ed1f039e02286cacb8d097f233e">khc_init</a> (<a class="el" href="structkhc.html">khc</a> *<a class="el" href="structkhc.html">khc</a>)</td></tr>
<tr class="memdesc:a5cb75ed1f039e02286cacb8d097f233e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set initial value to members of khc.  <a href="#a5cb75ed1f039e02286cacb8d097f233e">More...</a><br /></td></tr>
<tr class="separator:a5cb75ed1f039e02286cacb8d097f233e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7b6dde93cd97fc303a90c1414dba21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="khc_8h.html#aea7b6dde93cd97fc303a90c1414dba21">khc_reset_except_cb</a> (<a class="el" href="structkhc.html">khc</a> *<a class="el" href="structkhc.html">khc</a>)</td></tr>
<tr class="memdesc:aea7b6dde93cd97fc303a90c1414dba21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set initial value to members of khc other than callbacks.  <a href="#aea7b6dde93cd97fc303a90c1414dba21">More...</a><br /></td></tr>
<tr class="separator:aea7b6dde93cd97fc303a90c1414dba21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75fd843af7f3de58bcba2d348878becc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789">khc_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="khc_8h.html#a75fd843af7f3de58bcba2d348878becc">khc_perform</a> (<a class="el" href="structkhc.html">khc</a> *<a class="el" href="structkhc.html">khc</a>)</td></tr>
<tr class="memdesc:a75fd843af7f3de58bcba2d348878becc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the HTTP session.  <a href="#a75fd843af7f3de58bcba2d348878becc">More...</a><br /></td></tr>
<tr class="separator:a75fd843af7f3de58bcba2d348878becc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67fb3bf7ff0b65085e639aa5a1465cc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789">khc_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="khc_8h.html#a67fb3bf7ff0b65085e639aa5a1465cc3">khc_set_host</a> (<a class="el" href="structkhc.html">khc</a> *<a class="el" href="structkhc.html">khc</a>, const char *host)</td></tr>
<tr class="memdesc:a67fb3bf7ff0b65085e639aa5a1465cc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set host.  <a href="#a67fb3bf7ff0b65085e639aa5a1465cc3">More...</a><br /></td></tr>
<tr class="separator:a67fb3bf7ff0b65085e639aa5a1465cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d6d377286feccbf320117f7ffa1692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789">khc_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="khc_8h.html#a66d6d377286feccbf320117f7ffa1692">khc_set_path</a> (<a class="el" href="structkhc.html">khc</a> *<a class="el" href="structkhc.html">khc</a>, const char *path)</td></tr>
<tr class="memdesc:a66d6d377286feccbf320117f7ffa1692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set path.  <a href="#a66d6d377286feccbf320117f7ffa1692">More...</a><br /></td></tr>
<tr class="separator:a66d6d377286feccbf320117f7ffa1692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f16b241faeeb8e623e605fac9ed3901"><td class="memItemLeft" align="right" valign="top"><a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789">khc_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="khc_8h.html#a3f16b241faeeb8e623e605fac9ed3901">khc_set_method</a> (<a class="el" href="structkhc.html">khc</a> *<a class="el" href="structkhc.html">khc</a>, const char *method)</td></tr>
<tr class="memdesc:a3f16b241faeeb8e623e605fac9ed3901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set HTTP method.  <a href="#a3f16b241faeeb8e623e605fac9ed3901">More...</a><br /></td></tr>
<tr class="separator:a3f16b241faeeb8e623e605fac9ed3901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28ce7ac10ab32d62f0bdc0c5f3915c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789">khc_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="khc_8h.html#ac28ce7ac10ab32d62f0bdc0c5f3915c2">khc_set_req_headers</a> (<a class="el" href="structkhc.html">khc</a> *<a class="el" href="structkhc.html">khc</a>, <a class="el" href="structkhc__slist.html">khc_slist</a> *headers)</td></tr>
<tr class="memdesc:ac28ce7ac10ab32d62f0bdc0c5f3915c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set request headers.  <a href="#ac28ce7ac10ab32d62f0bdc0c5f3915c2">More...</a><br /></td></tr>
<tr class="separator:ac28ce7ac10ab32d62f0bdc0c5f3915c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2065be9638acf043438ac9e020d3b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="khc_8h.html#afd2065be9638acf043438ac9e020d3b8">khc_set_resp_header_buff</a> (<a class="el" href="structkhc.html">khc</a> *<a class="el" href="structkhc.html">khc</a>, char *buffer, size_t buff_size)</td></tr>
<tr class="memdesc:afd2065be9638acf043438ac9e020d3b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set response header buffer.  <a href="#afd2065be9638acf043438ac9e020d3b8">More...</a><br /></td></tr>
<tr class="separator:afd2065be9638acf043438ac9e020d3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a8813c4c65fb2097b3461e5303d4fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="khc_8h.html#a59a8813c4c65fb2097b3461e5303d4fa">khc_set_stream_buff</a> (<a class="el" href="structkhc.html">khc</a> *<a class="el" href="structkhc.html">khc</a>, char *buffer, size_t buff_size)</td></tr>
<tr class="memdesc:a59a8813c4c65fb2097b3461e5303d4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set stream buffer.  <a href="#a59a8813c4c65fb2097b3461e5303d4fa">More...</a><br /></td></tr>
<tr class="separator:a59a8813c4c65fb2097b3461e5303d4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f8f9bdcb11eead39b1665d705c5465"><td class="memItemLeft" align="right" valign="top"><a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789">khc_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="khc_8h.html#a54f8f9bdcb11eead39b1665d705c5465">khc_set_cb_sock_connect</a> (<a class="el" href="structkhc.html">khc</a> *<a class="el" href="structkhc.html">khc</a>, <a class="el" href="khc__socket__callback_8h.html#ae9552240ec64ad637e77cd63c3b65c65">KHC_CB_SOCK_CONNECT</a> cb, void *userdata)</td></tr>
<tr class="memdesc:a54f8f9bdcb11eead39b1665d705c5465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set socket connect callback.  <a href="#a54f8f9bdcb11eead39b1665d705c5465">More...</a><br /></td></tr>
<tr class="separator:a54f8f9bdcb11eead39b1665d705c5465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02713f2a404eb6f1487ecef3ce5fe2d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789">khc_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="khc_8h.html#a02713f2a404eb6f1487ecef3ce5fe2d9">khc_set_cb_sock_send</a> (<a class="el" href="structkhc.html">khc</a> *<a class="el" href="structkhc.html">khc</a>, <a class="el" href="khc__socket__callback_8h.html#a96345c64c6bcec1711d2ddaac43224c2">KHC_CB_SOCK_SEND</a> cb, void *userdata)</td></tr>
<tr class="memdesc:a02713f2a404eb6f1487ecef3ce5fe2d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set socket send callback.  <a href="#a02713f2a404eb6f1487ecef3ce5fe2d9">More...</a><br /></td></tr>
<tr class="separator:a02713f2a404eb6f1487ecef3ce5fe2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af922aa613df95d2c8bb10a2844d1d399"><td class="memItemLeft" align="right" valign="top"><a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789">khc_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="khc_8h.html#af922aa613df95d2c8bb10a2844d1d399">khc_set_cb_sock_recv</a> (<a class="el" href="structkhc.html">khc</a> *<a class="el" href="structkhc.html">khc</a>, <a class="el" href="khc__socket__callback_8h.html#a148cf4bd26b43909c9eab71f37b4cda6">KHC_CB_SOCK_RECV</a> cb, void *userdata)</td></tr>
<tr class="memdesc:af922aa613df95d2c8bb10a2844d1d399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set socket recv callback.  <a href="#af922aa613df95d2c8bb10a2844d1d399">More...</a><br /></td></tr>
<tr class="separator:af922aa613df95d2c8bb10a2844d1d399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0902ecf7e31cc403467fafbb7c287c6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789">khc_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="khc_8h.html#a0902ecf7e31cc403467fafbb7c287c6d">khc_set_cb_sock_close</a> (<a class="el" href="structkhc.html">khc</a> *<a class="el" href="structkhc.html">khc</a>, <a class="el" href="khc__socket__callback_8h.html#af54fb240d589fb1044188bd4a81ab78d">KHC_CB_SOCK_CLOSE</a> cb, void *userdata)</td></tr>
<tr class="memdesc:a0902ecf7e31cc403467fafbb7c287c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set socket close callback.  <a href="#a0902ecf7e31cc403467fafbb7c287c6d">More...</a><br /></td></tr>
<tr class="separator:a0902ecf7e31cc403467fafbb7c287c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea30cbdfd91b2ba3bb156bfa693bcab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789">khc_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="khc_8h.html#a1ea30cbdfd91b2ba3bb156bfa693bcab">khc_set_cb_read</a> (<a class="el" href="structkhc.html">khc</a> *<a class="el" href="structkhc.html">khc</a>, <a class="el" href="khc_8h.html#a3b82452e6a8981c670e9eef8450a7ce4">KHC_CB_READ</a> cb, void *userdata)</td></tr>
<tr class="memdesc:a1ea30cbdfd91b2ba3bb156bfa693bcab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set read callback.  <a href="#a1ea30cbdfd91b2ba3bb156bfa693bcab">More...</a><br /></td></tr>
<tr class="separator:a1ea30cbdfd91b2ba3bb156bfa693bcab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6acc9ee82789a8986a4a2b7e586a6f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789">khc_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="khc_8h.html#ac6acc9ee82789a8986a4a2b7e586a6f0">khc_set_cb_write</a> (<a class="el" href="structkhc.html">khc</a> *<a class="el" href="structkhc.html">khc</a>, <a class="el" href="khc_8h.html#a57e8d1b5da9a4222190c74f8fb87a304">KHC_CB_WRITE</a> cb, void *userdata)</td></tr>
<tr class="memdesc:ac6acc9ee82789a8986a4a2b7e586a6f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set write callback.  <a href="#ac6acc9ee82789a8986a4a2b7e586a6f0">More...</a><br /></td></tr>
<tr class="separator:ac6acc9ee82789a8986a4a2b7e586a6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe54c0defe07585305e7a5c52a772b7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789">khc_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="khc_8h.html#afe54c0defe07585305e7a5c52a772b7f">khc_set_cb_header</a> (<a class="el" href="structkhc.html">khc</a> *<a class="el" href="structkhc.html">khc</a>, <a class="el" href="khc_8h.html#a28da65fe4a96bed6b6ac8150b9481a20">KHC_CB_HEADER</a> cb, void *userdata)</td></tr>
<tr class="memdesc:afe54c0defe07585305e7a5c52a772b7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set header callback.  <a href="#afe54c0defe07585305e7a5c52a772b7f">More...</a><br /></td></tr>
<tr class="separator:afe54c0defe07585305e7a5c52a772b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdd7cfba271620aa0bcaadae490936b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="khc_8h.html#a9bdd7cfba271620aa0bcaadae490936b">khc_enable_insecure</a> (<a class="el" href="structkhc.html">khc</a> *<a class="el" href="structkhc.html">khc</a>, int enable_insecure)</td></tr>
<tr class="memdesc:a9bdd7cfba271620aa0bcaadae490936b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable insecure connection.  <a href="#a9bdd7cfba271620aa0bcaadae490936b">More...</a><br /></td></tr>
<tr class="separator:a9bdd7cfba271620aa0bcaadae490936b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3313d6c8555ee7aedb75870992c449"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="khc_8h.html#afa3313d6c8555ee7aedb75870992c449">khc_get_status_code</a> (<a class="el" href="structkhc.html">khc</a> *<a class="el" href="structkhc.html">khc</a>)</td></tr>
<tr class="memdesc:afa3313d6c8555ee7aedb75870992c449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get HTTP status code.  <a href="#afa3313d6c8555ee7aedb75870992c449">More...</a><br /></td></tr>
<tr class="separator:afa3313d6c8555ee7aedb75870992c449"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Kii HTTP clinet public API definitions. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a962c972213b49a6581a83f890fe22a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a962c972213b49a6581a83f890fe22a0b">&#9670;&nbsp;</a></span>khc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structkhc.html">khc</a>  <a class="el" href="structkhc.html">khc</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>khc object. </p>
<p>Reference/ change members of khc instance must be done by APIs takes pointer of the khc object instance. Do not reference/ change members directly. </p>

</div>
</div>
<a id="a28da65fe4a96bed6b6ac8150b9481a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28da65fe4a96bed6b6ac8150b9481a20">&#9670;&nbsp;</a></span>KHC_CB_HEADER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t(* KHC_CB_HEADER) (char *buffer, size_t size, void *userdata)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback used to propagate response headers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>response header data. Note that the buffer is not null terminated. The buffer does not contains CRLF. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>header data size. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">userdata</td><td>context data passed to <a class="el" href="khc_8h.html#afe54c0defe07585305e7a5c52a772b7f" title="Set header callback. ">khc_set_cb_header(khc*, KHC_CB_HEADER, void*)</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of the bytes handled. If it is not equal to Header size determined by size, khc aborts HTTP session and <a class="el" href="khc_8h.html#a75fd843af7f3de58bcba2d348878becc" title="Perform the HTTP session. ">khc_perform(khc*)</a> returns KHC_ERR_HEADER_CALLBACK. </dd></dl>

</div>
</div>
<a id="a3b82452e6a8981c670e9eef8450a7ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b82452e6a8981c670e9eef8450a7ce4">&#9670;&nbsp;</a></span>KHC_CB_READ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t(* KHC_CB_READ) (char *buffer, size_t size, void *userdata)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback reads data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>callback must writes data to this buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>requested read size. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">userdata</td><td>context data passed to <a class="el" href="khc_8h.html#a1ea30cbdfd91b2ba3bb156bfa693bcab" title="Set read callback. ">khc_set_cb_read(khc*, KHC_CB_READ, void*)</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of the bytes read. Returning 0 indicates that the whole data is read. khc repeatedly call this callback until it returns 0. </dd></dl>

</div>
</div>
<a id="ab4d588005d08dee796a1c9c830dc4590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4d588005d08dee796a1c9c830dc4590">&#9670;&nbsp;</a></span>KHC_CB_SLIST_ALLOC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structkhc__slist.html">khc_slist</a>*(* KHC_CB_SLIST_ALLOC) (const char *str, size_t str_length, void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Custom <a class="el" href="structkhc__slist.html" title="Linked list. ">khc_slist</a> node allocator. </p>
<p>In this allocator, you need to allocate memory of <a class="el" href="structkhc__slist.html" title="Linked list. ">khc_slist</a> struct and it's data char array. data char array must be NULL terminated so it requires str_length + 1 as length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td><a class="el" href="structkhc__slist.html" title="Linked list. ">khc_slist</a> content. String must be copied to <a class="el" href="structkhc__slist.html#afdc9bd8e86890913ee8949a9275bf0b6" title="Null terminated string. ">khc_slist.data</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str_length</td><td>length of the string (exclude NULL termination). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>optional context data pointer. The pointer is given by <a class="el" href="khc_8h.html#acda920e221cf9a457dd9e3f82197d2d7" title="Add node to the linked list. Node is allocated by specified allocator. ">khc_slist_append_using_cb_alloc(khc_slist*, const char*, size_t, KHC_CB_SLIST_ALLOC, void*)</a> method and could be NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32bafb6cf1da963a57d8a167efe9f833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32bafb6cf1da963a57d8a167efe9f833">&#9670;&nbsp;</a></span>KHC_CB_SLIST_FREE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* KHC_CB_SLIST_FREE) (<a class="el" href="structkhc__slist.html">khc_slist</a> *node, void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\ brief free memory allocated by custom <a class="el" href="structkhc__slist.html" title="Linked list. ">khc_slist</a> node allocator.</p>
<p>In this callback, implementation must free memory allocated by single <a class="el" href="structkhc__slist.html" title="Linked list. ">khc_slist</a> node. Method must be corresponding to alloc method implemented in KHC_CB_SLIST_ALLOC.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>of the slist. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Context data pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57e8d1b5da9a4222190c74f8fb87a304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57e8d1b5da9a4222190c74f8fb87a304">&#9670;&nbsp;</a></span>KHC_CB_WRITE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t(* KHC_CB_WRITE) (char *buffer, size_t size, void *userdata)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback writes data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>data to be written. Note that it is not null terminated string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>data size to be written. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">userdata</td><td>context data passed to <a class="el" href="khc_8h.html#ac6acc9ee82789a8986a4a2b7e586a6f0" title="Set write callback. ">khc_set_cb_write(khc*, KHC_CB_WRITE, void*)</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of the bytes written. If the returned value is not equal to requested size, khc aborts HTTP session and <a class="el" href="khc_8h.html#a75fd843af7f3de58bcba2d348878becc" title="Perform the HTTP session. ">khc_perform(khc*)</a> returns KHC_ERR_WRITE_CALLBACK. </dd></dl>

</div>
</div>
<a id="a405624d71b2722c439683872c851fc8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a405624d71b2722c439683872c851fc8b">&#9670;&nbsp;</a></span>khc_slist</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structkhc__slist.html">khc_slist</a>  <a class="el" href="structkhc__slist.html">khc_slist</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linked list. </p>
<p>Linked list manages c string data. </p>

</div>
</div>
<a id="ae53a38ebe7cf84dfb5f5892785c74b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53a38ebe7cf84dfb5f5892785c74b8f">&#9670;&nbsp;</a></span>khc_state</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="khc_8h.html#a857caeeab83df303d0fe3a7d97601d0f">khc_state</a>  <a class="el" href="khc_8h.html#a857caeeab83df303d0fe3a7d97601d0f">khc_state</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicate state of khc. </p>
<p>No need to reference state of khc to run HTTP session. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a90be23875108e9a39942c3af90a6d789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90be23875108e9a39942c3af90a6d789">&#9670;&nbsp;</a></span>khc_code</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789">khc_code</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error codes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a90be23875108e9a39942c3af90a6d789ad362084b96bd996b692883323f38a71d"></a>KHC_ERR_OK&#160;</td><td class="fielddoc"><p>Operation succeeded. </p>
<p>Failure in connecting to server. </p>
</td></tr>
<tr><td class="fieldname"><a id="a90be23875108e9a39942c3af90a6d789a63860890be328ec70b59ee94e6b3fa79"></a>KHC_ERR_SOCK_CONNECT&#160;</td><td class="fielddoc"><p>Failure in closing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="a90be23875108e9a39942c3af90a6d789a8371726af4f71dd9286834d572befa8a"></a>KHC_ERR_SOCK_CLOSE&#160;</td><td class="fielddoc"><p>Failure in sending data. </p>
</td></tr>
<tr><td class="fieldname"><a id="a90be23875108e9a39942c3af90a6d789a23f70a0ca5536d5538cd259c0988a5d1"></a>KHC_ERR_SOCK_SEND&#160;</td><td class="fielddoc"><p>Failure in receiving data. </p>
</td></tr>
<tr><td class="fieldname"><a id="a90be23875108e9a39942c3af90a6d789aa19da1c09bffcd5bf90a4a52295e8054"></a>KHC_ERR_SOCK_RECV&#160;</td><td class="fielddoc"><p>Failure in handling response headers. </p>
</td></tr>
<tr><td class="fieldname"><a id="a90be23875108e9a39942c3af90a6d789a87e69245b830da2d3cfee093ee5db0ee"></a>KHC_ERR_HEADER_CALLBACK&#160;</td><td class="fielddoc"><p>Failure in handling response body. </p>
</td></tr>
<tr><td class="fieldname"><a id="a90be23875108e9a39942c3af90a6d789af5c7c4c210efc30b9d3cf642a0342f52"></a>KHC_ERR_WRITE_CALLBACK&#160;</td><td class="fielddoc"><p>Memory allocation error. </p>
</td></tr>
<tr><td class="fieldname"><a id="a90be23875108e9a39942c3af90a6d789a312c4dc6d68bf167f83aedc8def54cb1"></a>KHC_ERR_ALLOCATION&#160;</td><td class="fielddoc"><p>Data is too large and doesn't fit to buffers statically allocated. </p>
</td></tr>
<tr><td class="fieldname"><a id="a90be23875108e9a39942c3af90a6d789abdc61249fe00e89ee9f2d00f11561e13"></a>KHC_ERR_TOO_LARGE_DATA&#160;</td><td class="fielddoc"><p>Other errors. </p>
</td></tr>
</table>

</div>
</div>
<a id="a857caeeab83df303d0fe3a7d97601d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a857caeeab83df303d0fe3a7d97601d0f">&#9670;&nbsp;</a></span>khc_state</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="khc_8h.html#a857caeeab83df303d0fe3a7d97601d0f">khc_state</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicate state of khc. </p>
<p>No need to reference state of khc to run HTTP session. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9bdd7cfba271620aa0bcaadae490936b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bdd7cfba271620aa0bcaadae490936b">&#9670;&nbsp;</a></span>khc_enable_insecure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void khc_enable_insecure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkhc.html">khc</a> *&#160;</td>
          <td class="paramname"><em>khc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enable_insecure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable insecure connection. </p>
<p>By default, khc uses secure connection. If you need to use tcp instead of ssl/tls, you need to call this method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">khc</td><td>instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable_insecure</td><td>non-zero indicates enabling insecure connection. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa3313d6c8555ee7aedb75870992c449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa3313d6c8555ee7aedb75870992c449">&#9670;&nbsp;</a></span>khc_get_status_code()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int khc_get_status_code </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkhc.html">khc</a> *&#160;</td>
          <td class="paramname"><em>khc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get HTTP status code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">khc</td><td>instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HTTP status code. </dd></dl>

</div>
</div>
<a id="a5cb75ed1f039e02286cacb8d097f233e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cb75ed1f039e02286cacb8d097f233e">&#9670;&nbsp;</a></span>khc_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void khc_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkhc.html">khc</a> *&#160;</td>
          <td class="paramname"><em>khc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set initial value to members of khc. </p>
<p>You need to call this method when start using khc instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">khc</td><td>instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="khc_8h.html#aea7b6dde93cd97fc303a90c1414dba21" title="Set initial value to members of khc other than callbacks. ">khc_reset_except_cb(khc*)</a> </dd></dl>

</div>
</div>
<a id="a75fd843af7f3de58bcba2d348878becc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75fd843af7f3de58bcba2d348878becc">&#9670;&nbsp;</a></span>khc_perform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789">khc_code</a> khc_perform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkhc.html">khc</a> *&#160;</td>
          <td class="paramname"><em>khc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform the HTTP session. </p>
<p>During the session, callback functions set by <a class="el" href="khc_8h.html#a54f8f9bdcb11eead39b1665d705c5465" title="Set socket connect callback. ">khc_set_cb_sock_connect(khc*, KHC_CB_SOCK_CONNECT, void*)</a>, <a class="el" href="khc_8h.html#a02713f2a404eb6f1487ecef3ce5fe2d9" title="Set socket send callback. ">khc_set_cb_sock_send(khc*, KHC_CB_SOCK_SEND, void*)</a>, <a class="el" href="khc_8h.html#af922aa613df95d2c8bb10a2844d1d399" title="Set socket recv callback. ">khc_set_cb_sock_recv(khc*, KHC_CB_SOCK_RECV, void*)</a>, <a class="el" href="khc_8h.html#a0902ecf7e31cc403467fafbb7c287c6d" title="Set socket close callback. ">khc_set_cb_sock_close(khc*, KHC_CB_SOCK_CLOSE, void*)</a>, <a class="el" href="khc_8h.html#a1ea30cbdfd91b2ba3bb156bfa693bcab" title="Set read callback. ">khc_set_cb_read(khc*, KHC_CB_READ, void*)</a>, <a class="el" href="khc_8h.html#ac6acc9ee82789a8986a4a2b7e586a6f0" title="Set write callback. ">khc_set_cb_write(khc*, KHC_CB_WRITE, void*)</a> and <a class="el" href="khc_8h.html#afe54c0defe07585305e7a5c52a772b7f" title="Set header callback. ">khc_set_cb_header(khc*, KHC_CB_HEADER, void*)</a> called. This method blocks until the HTTP session ends. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">khc</td><td>instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea7b6dde93cd97fc303a90c1414dba21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea7b6dde93cd97fc303a90c1414dba21">&#9670;&nbsp;</a></span>khc_reset_except_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void khc_reset_except_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkhc.html">khc</a> *&#160;</td>
          <td class="paramname"><em>khc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set initial value to members of khc other than callbacks. </p>
<p>Callbacks/ userdata set by following methods remain untouched. <a class="el" href="khc_8h.html#a54f8f9bdcb11eead39b1665d705c5465" title="Set socket connect callback. ">khc_set_cb_sock_connect(khc*, KHC_CB_SOCK_CONNECT, void*)</a>, <a class="el" href="khc_8h.html#a02713f2a404eb6f1487ecef3ce5fe2d9" title="Set socket send callback. ">khc_set_cb_sock_send(khc*, KHC_CB_SOCK_SEND, void*)</a>, <a class="el" href="khc_8h.html#af922aa613df95d2c8bb10a2844d1d399" title="Set socket recv callback. ">khc_set_cb_sock_recv(khc*, KHC_CB_SOCK_RECV, void*)</a>, <a class="el" href="khc_8h.html#a0902ecf7e31cc403467fafbb7c287c6d" title="Set socket close callback. ">khc_set_cb_sock_close(khc*, KHC_CB_SOCK_CLOSE, void*)</a>, <a class="el" href="khc_8h.html#a1ea30cbdfd91b2ba3bb156bfa693bcab" title="Set read callback. ">khc_set_cb_read(khc*, KHC_CB_READ, void*)</a>, <a class="el" href="khc_8h.html#ac6acc9ee82789a8986a4a2b7e586a6f0" title="Set write callback. ">khc_set_cb_write(khc*, KHC_CB_WRITE, void*)</a> and <a class="el" href="khc_8h.html#afe54c0defe07585305e7a5c52a772b7f" title="Set header callback. ">khc_set_cb_header(khc*, KHC_CB_HEADER, void*)</a></p>
<p>You may use this method when you start new session and reuse same callbacks and userdata pointers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">khc</td><td>instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="khc_8h.html#a5cb75ed1f039e02286cacb8d097f233e" title="Set initial value to members of khc. ">khc_init(khc*)</a> </dd></dl>

</div>
</div>
<a id="afe54c0defe07585305e7a5c52a772b7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe54c0defe07585305e7a5c52a772b7f">&#9670;&nbsp;</a></span>khc_set_cb_header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789">khc_code</a> khc_set_cb_header </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkhc.html">khc</a> *&#160;</td>
          <td class="paramname"><em>khc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="khc_8h.html#a28da65fe4a96bed6b6ac8150b9481a20">KHC_CB_HEADER</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set header callback. </p>
<p>The callback is called while reading response headers. Callback would be called several times until all response headers are processed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">khc</td><td>instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>response header callback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userdata</td><td>context data of the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ea30cbdfd91b2ba3bb156bfa693bcab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ea30cbdfd91b2ba3bb156bfa693bcab">&#9670;&nbsp;</a></span>khc_set_cb_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789">khc_code</a> khc_set_cb_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkhc.html">khc</a> *&#160;</td>
          <td class="paramname"><em>khc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="khc_8h.html#a3b82452e6a8981c670e9eef8450a7ce4">KHC_CB_READ</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set read callback. </p>
<p>The callback is called to read request body data. Callback would be called several times until the length of data read by the callback is 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">khc</td><td>instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>reads request body. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userdata</td><td>context data of the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0902ecf7e31cc403467fafbb7c287c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0902ecf7e31cc403467fafbb7c287c6d">&#9670;&nbsp;</a></span>khc_set_cb_sock_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789">khc_code</a> khc_set_cb_sock_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkhc.html">khc</a> *&#160;</td>
          <td class="paramname"><em>khc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="khc__socket__callback_8h.html#af54fb240d589fb1044188bd4a81ab78d">KHC_CB_SOCK_CLOSE</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set socket close callback. </p>
<p>NOTE: Currently khc uses HTTP 1.0 and close callback is called each HTTP session. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">khc</td><td>instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>called when HTTP session ends. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userdata</td><td>context data of the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54f8f9bdcb11eead39b1665d705c5465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f8f9bdcb11eead39b1665d705c5465">&#9670;&nbsp;</a></span>khc_set_cb_sock_connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789">khc_code</a> khc_set_cb_sock_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkhc.html">khc</a> *&#160;</td>
          <td class="paramname"><em>khc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="khc__socket__callback_8h.html#ae9552240ec64ad637e77cd63c3b65c65">KHC_CB_SOCK_CONNECT</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set socket connect callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">khc</td><td>instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>called when socket connection to the server is required. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userdata</td><td>context data of the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af922aa613df95d2c8bb10a2844d1d399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af922aa613df95d2c8bb10a2844d1d399">&#9670;&nbsp;</a></span>khc_set_cb_sock_recv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789">khc_code</a> khc_set_cb_sock_recv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkhc.html">khc</a> *&#160;</td>
          <td class="paramname"><em>khc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="khc__socket__callback_8h.html#a148cf4bd26b43909c9eab71f37b4cda6">KHC_CB_SOCK_RECV</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set socket recv callback. </p>
<p>Callback would be called several times until the length of data read by the callback is 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">khc</td><td>instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>called when receive data from the connected server is required. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userdata</td><td>context data of the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02713f2a404eb6f1487ecef3ce5fe2d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02713f2a404eb6f1487ecef3ce5fe2d9">&#9670;&nbsp;</a></span>khc_set_cb_sock_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789">khc_code</a> khc_set_cb_sock_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkhc.html">khc</a> *&#160;</td>
          <td class="paramname"><em>khc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="khc__socket__callback_8h.html#a96345c64c6bcec1711d2ddaac43224c2">KHC_CB_SOCK_SEND</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set socket send callback. </p>
<p>Callback would be called several times during the HTTP session depending on the size of the request. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">khc</td><td>instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>called when send data to the connected server is required. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userdata</td><td>context data of the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6acc9ee82789a8986a4a2b7e586a6f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6acc9ee82789a8986a4a2b7e586a6f0">&#9670;&nbsp;</a></span>khc_set_cb_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789">khc_code</a> khc_set_cb_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkhc.html">khc</a> *&#160;</td>
          <td class="paramname"><em>khc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="khc_8h.html#a57e8d1b5da9a4222190c74f8fb87a304">KHC_CB_WRITE</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set write callback. </p>
<p>The callback is called while reading response body. Callback would be called several times until the whole response body is written. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">khc</td><td>instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>writes response body. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userdata</td><td>context data of the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67fb3bf7ff0b65085e639aa5a1465cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67fb3bf7ff0b65085e639aa5a1465cc3">&#9670;&nbsp;</a></span>khc_set_host()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789">khc_code</a> khc_set_host </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkhc.html">khc</a> *&#160;</td>
          <td class="paramname"><em>khc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set host. </p>
<p>Host consists of URL in request line. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">khc</td><td>instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">host</td><td>must be null terminated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f16b241faeeb8e623e605fac9ed3901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f16b241faeeb8e623e605fac9ed3901">&#9670;&nbsp;</a></span>khc_set_method()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789">khc_code</a> khc_set_method </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkhc.html">khc</a> *&#160;</td>
          <td class="paramname"><em>khc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set HTTP method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">khc</td><td>instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>must be null terminated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66d6d377286feccbf320117f7ffa1692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66d6d377286feccbf320117f7ffa1692">&#9670;&nbsp;</a></span>khc_set_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789">khc_code</a> khc_set_path </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkhc.html">khc</a> *&#160;</td>
          <td class="paramname"><em>khc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set path. </p>
<p>Path consists of URL in request line. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">khc</td><td>instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>must be null terminated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac28ce7ac10ab32d62f0bdc0c5f3915c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac28ce7ac10ab32d62f0bdc0c5f3915c2">&#9670;&nbsp;</a></span>khc_set_req_headers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="khc_8h.html#a90be23875108e9a39942c3af90a6d789">khc_code</a> khc_set_req_headers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkhc.html">khc</a> *&#160;</td>
          <td class="paramname"><em>khc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structkhc__slist.html">khc_slist</a> *&#160;</td>
          <td class="paramname"><em>headers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set request headers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">khc</td><td>instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">headers</td><td>list of request headers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd2065be9638acf043438ac9e020d3b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd2065be9638acf043438ac9e020d3b8">&#9670;&nbsp;</a></span>khc_set_resp_header_buff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void khc_set_resp_header_buff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkhc.html">khc</a> *&#160;</td>
          <td class="paramname"><em>khc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buff_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set response header buffer. </p>
<p>Set response header buffer pointer used by KHC_CB_HEADER. If this method is not called or set NULL to the buffer, khc allocates memory of response header buffer when the HTTP session started and free when the HTTP session ends. The buffer allocated by the khc is 256 bytes.</p>
<p>The buffer is used to store single HTTP response header. If header is larger than the buffer, the header is skipped and KHC_CB_HEADER is not called. khc needs to parse Status Line, Content-Length, Transfer-Encoding header to process HTTP message. The buffer must have enough size to store those headers. 256 bytes would be enough. If you set the buffer by the method, the method must be called befor <a class="el" href="khc_8h.html#a75fd843af7f3de58bcba2d348878becc" title="Perform the HTTP session. ">khc_perform(khc*)</a> and memory used by the buffer can be safely freed after <a class="el" href="khc_8h.html#a75fd843af7f3de58bcba2d348878becc" title="Perform the HTTP session. ">khc_perform(khc*)</a> returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">khc</td><td>instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buff_size</td><td>size of the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59a8813c4c65fb2097b3461e5303d4fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a8813c4c65fb2097b3461e5303d4fa">&#9670;&nbsp;</a></span>khc_set_stream_buff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void khc_set_stream_buff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkhc.html">khc</a> *&#160;</td>
          <td class="paramname"><em>khc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buff_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set stream buffer. </p>
<p>Set stream buffer pointer used by KHC_CB_READ, KHC_CB_WRITE. If this method is not called or set NULL to the buffer, khc allocates memory of stream buffer when the HTTP session started and free when the HTTP session ends. The buffer allocated by khc is 1024 bytes.</p>
<p>You can change the size of buffer depending on your request/ response size. It must be enough large to store size line in chunked encoded message. However, you may use much larger buffer since size line might require very small buffer as it consists of HEX size and CRLF for the better performance. If you set the buffer by the method, the method must be called befor <a class="el" href="khc_8h.html#a75fd843af7f3de58bcba2d348878becc" title="Perform the HTTP session. ">khc_perform(khc*)</a> and memory used by the buffer can be safely freed after <a class="el" href="khc_8h.html#a75fd843af7f3de58bcba2d348878becc" title="Perform the HTTP session. ">khc_perform(khc*)</a> returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">khc</td><td>instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buff_size</td><td>size of the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a21016c7cd604d2476b97a8f6521106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a21016c7cd604d2476b97a8f6521106">&#9670;&nbsp;</a></span>khc_slist_append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structkhc__slist.html">khc_slist</a>* khc_slist_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkhc__slist.html">khc_slist</a> *&#160;</td>
          <td class="paramname"><em>slist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add node to the linked list. </p>
<p>This method uses default memory allocator uses malloc() for constructing string copy and <a class="el" href="structkhc__slist.html" title="Linked list. ">khc_slist</a>. <a class="el" href="structkhc__slist.html" title="Linked list. ">khc_slist</a> must be appended by this method if the previous node is appended by this method. <a class="el" href="khc_8h.html#a0697b94cf117f1e6475d4b6a281fdab6" title="Free memory used for the entire linked list. ">khc_slist_free_all(khc_slist*)</a> must be called to free all memories used by the list. You can't use different allocate/ free method specified by <a class="el" href="khc_8h.html#acda920e221cf9a457dd9e3f82197d2d7" title="Add node to the linked list. Node is allocated by specified allocator. ">khc_slist_append_using_cb_alloc(khc_slist*, const char*, size_t length, KHC_CB_SLIST_ALLOC, void*)</a> in a single list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">slist</td><td>pointer to the linked list or NULL to create new linked list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>data to be appended. String is copied to new char array in slist. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>of the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the linked list (first node). </dd></dl>

</div>
</div>
<a id="acda920e221cf9a457dd9e3f82197d2d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda920e221cf9a457dd9e3f82197d2d7">&#9670;&nbsp;</a></span>khc_slist_append_using_cb_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structkhc__slist.html">khc_slist</a>* khc_slist_append_using_cb_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkhc__slist.html">khc_slist</a> *&#160;</td>
          <td class="paramname"><em>slist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="khc_8h.html#ab4d588005d08dee796a1c9c830dc4590">KHC_CB_SLIST_ALLOC</a>&#160;</td>
          <td class="paramname"><em>cb_alloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_alloc_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add node to the linked list. Node is allocated by specified allocator. </p>
<p>This method uses custom memory allocator for constructing string copy and <a class="el" href="structkhc__slist.html" title="Linked list. ">khc_slist</a>. <a class="el" href="structkhc__slist.html" title="Linked list. ">khc_slist</a> must be appended by this method and same allocator if the previous node is appended by this method. <a class="el" href="khc_8h.html#a601f7b3c5298824462683436df2807fa" title="Free memory used for the entire linked list constructed by custom allocator. ">khc_slist_free_all_using_cb_free(khc_slist*, KHC_CB_SLIST_FREE, void*)</a> and matching free callback must be used to free all memories used by the list. You can't use different allocate/ free method specified by <a class="el" href="khc_8h.html#acda920e221cf9a457dd9e3f82197d2d7" title="Add node to the linked list. Node is allocated by specified allocator. ">khc_slist_append_using_cb_alloc(khc_slist*, const char*, size_t length, KHC_CB_SLIST_ALLOC, void*)</a> in a single list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">slist</td><td>pointer to the linked list or NULL to create new linked list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>data to be appended. String is copied to new char array in slist. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>of the string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_alloc</td><td>allocator callback function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_alloc_data</td><td>context data pointer passed to cb_alloc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the linked list (first node). </dd></dl>

</div>
</div>
<a id="a0697b94cf117f1e6475d4b6a281fdab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0697b94cf117f1e6475d4b6a281fdab6">&#9670;&nbsp;</a></span>khc_slist_free_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void khc_slist_free_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkhc__slist.html">khc_slist</a> *&#160;</td>
          <td class="paramname"><em>slist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free memory used for the entire linked list. </p>
<p>Linked list constructed by <a class="el" href="khc_8h.html#a8a21016c7cd604d2476b97a8f6521106" title="Add node to the linked list. ">khc_slist_append(khc_slist*, const char*, size_t)</a> must be freed by this method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">slist</td><td>pointer to the linked list (first node). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a601f7b3c5298824462683436df2807fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601f7b3c5298824462683436df2807fa">&#9670;&nbsp;</a></span>khc_slist_free_all_using_cb_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void khc_slist_free_all_using_cb_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkhc__slist.html">khc_slist</a> *&#160;</td>
          <td class="paramname"><em>slist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="khc_8h.html#a32bafb6cf1da963a57d8a167efe9f833">KHC_CB_SLIST_FREE</a>&#160;</td>
          <td class="paramname"><em>cb_free</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_free_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free memory used for the entire linked list constructed by custom allocator. </p>
<p>Linked list constructed by <a class="el" href="khc_8h.html#acda920e221cf9a457dd9e3f82197d2d7" title="Add node to the linked list. Node is allocated by specified allocator. ">khc_slist_append_using_cb_alloc(khc_slist*, const char*, size_t length, KHC_CB_SLIST_ALLOC, void*)</a> must be freed by this method and matching free callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">slist</td><td>pointer to the linked list (first node). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_free</td><td>free callback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_free_data</td><td>context object pointer passed to cb_free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Mar 6 2019 07:55:10 for khc by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
